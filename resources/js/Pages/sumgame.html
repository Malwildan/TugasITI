<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fruit Box - Sum to 10</title>
    <style>
        /* CSS Styling for New UI */
        body {
            margin: 0;
            padding: 0;
            background-color: #00c853; /* Main green background */
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #main-frame {
            background-color: #f0f0f0; /* Inner frame color */
            border: 10px solid #00e676; /* Lighter green border */
            border-radius: 15px;
            padding: 5px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
        }

        /* Header bar with score and time */
        #header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            color: #0a6b34;
            font-weight: 800;
        }
        .pill {
            background: #dff6e9;
            border: 2px solid #2cc56a;
            border-radius: 999px;
            padding: 6px 12px;
            color: #0a6b34;
        }

        #content-row {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        #canvas-container {
            position: relative;
            background-image: 
                linear-gradient(#e0e0e0 1px, transparent 1px),
                linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
            background-size: 30px 30px; /* Match cellSize */
            background-color: #fff;
        }

        canvas {
            cursor: crosshair;
            touch-action: none;
            display: block;
        }

        /* Score Display */
        #score-display {
            font-size: 18px;
            font-weight: bold;
            color: #0a6b34;
        }

        /* Vertical Timer Bar */
        #timer-container {
            margin-right: 5px;
            margin-bottom: 5px;
            width: 15px;
            height: 400px; /* Adjusted in resize */
            background-color: #ccc;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            justify-content: center; /* center horizontally */
            align-items: flex-end;   /* anchor bar to bottom */
            padding: 2px;            /* small inset */
            box-sizing: border-box;
        }

        #timer-bar {
            width: 20px;              /* slimmer bar, centered */
            height: 100%;
            background-color: #00c853;
            border-radius: 6px;
            transition: height 0.1s linear;
        }

        /* Bottom Control Bar */
        #control-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #00c853;
            color: #fff;
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }

        #reset-btn {
            background-color: rgba(255,255,255,0.2);
            border: 1px solid #fff;
            padding: 5px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .options-group {
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 14px;
        }

        .options-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .options-group input { margin-right: 5px; }

        #sound-slider {
            width: 60px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="main-frame">
        <div id="header-bar">
            <div class="pill">Sum Fruit</div>
            <div style="display:flex; gap:12px; align-items:center;">
                <div class="pill">Score: <span id="score-display">0</span></div>
                <div class="pill">Time: <span id="time-display">120</span>s</div>
                <a href="/dashboard" class="pill" style="text-decoration:none;">Back</a>
            </div>
        </div>

        <div id="content-row">
            <div id="canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>
            <div id="timer-container">
                <div id="timer-bar"></div>
            </div>
        </div>

        <div id="control-bar">
            <button id="reset-btn">Reset</button>
            <div class="options-group">
                <label><input type="checkbox" id="light-mode-toggle"> Light Colors</label>
                <label><input type="checkbox" id="bgm-toggle" checked> BGM</label>
                <span>ðŸŽµ</span>
                <input type="range" id="sound-slider" min="0" max="100" value="50">
            </div>
        </div>
    </div>

    <script>
        /**
         * FRUIT BOX - HTML5 CANVAS GAME
         * Core Logic:
         * 1. Grid of apples (10x17).
         * 2. Drag to select.
         * 3. If sum == 10, remove apples, score points, respawn.
         */

        // --- Configuration ---
        const GRID_COLS = 17; // grid width
        const GRID_ROWS = 10; // grid height
        const GAME_DURATION = 120; // seconds
        
        // --- State Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiScore = document.getElementById('score-display');
        const timerBar = document.getElementById('timer-bar');
        const timerContainer = document.getElementById('timer-container');
        const toggleLight = document.getElementById('light-mode-toggle');
        const resetBtn = document.getElementById('reset-btn');
        const container = document.getElementById('canvas-container');

        let apples = []; // Array to store apple objects
        let score = 0;
        let timeLeft = GAME_DURATION;
        let isGameOver = false;
        let isGameStarted = false; // start UI shown until user presses Start
        let timerInterval = null;
        let lastFrameTime = 0;

        // Visual settings
        let cellSize = 30; // Calculated dynamically
        let isLightMode = false;

        // Input state
        const input = {
            isDragging: false,
            startX: 0,
            startY: 0,
            currX: 0,
            currY: 0
        };

        // Feedback animation state
        let feedbackBox = null; // { x, y, w, h, color, timestamp }

        // --- Initialization ---

        function initGame() {
            // Event Listeners
            window.addEventListener('resize', resizeCanvas);
            toggleLight.addEventListener('change', (e) => {
                isLightMode = e.target.checked;
                draw(); // Redraw apples with new palette
            });
            resetBtn.addEventListener('click', () => {
                // Show start UI again on reset
                isGameStarted = false;
                isGameOver = false;
                score = 0;
                timeLeft = GAME_DURATION;
                apples = [];
                feedbackBox = null;
                if (timerInterval) clearInterval(timerInterval);
                updateUI();
                draw();
            });

            // Mouse Events
            canvas.addEventListener('mousedown', handleInputStart);
            window.addEventListener('mousemove', handleInputMove);
            window.addEventListener('mouseup', handleInputEnd);

            // Touch Events
            canvas.addEventListener('touchstart', handleInputStart, { passive: false });
            window.addEventListener('touchmove', handleInputMove, { passive: false });
            window.addEventListener('touchend', handleInputEnd);

            resizeCanvas(); // Trigger initial size calc
            // Do not start game until user presses Start
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            // Start from initial state
            isGameStarted = true;
            resetGame();
        }

        // --- Cheat Code: Double Space to end game ---
        let lastSpaceTime = 0;
        let spaceCountWindow = 0;
        window.addEventListener('keydown', (e) => {
            if (!isGameStarted || isGameOver) return;
            if (e.code === 'Space') {
                const now = performance.now();
                if (now - lastSpaceTime < 600) {
                    spaceCountWindow += 1;
                } else {
                    spaceCountWindow = 1;
                }
                lastSpaceTime = now;
                if (spaceCountWindow >= 2) {
                    // Trigger time's up UI
                    endGame();
                }
                // Prevent page scroll on space
                e.preventDefault();
            }
        });

        function resetGame() {
            score = 0;
            timeLeft = GAME_DURATION;
            isGameOver = false;
            apples = [];
            feedbackBox = null;
            updateUI();

            // Populate Grid
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    spawnAppleAt(r, c);
                }
            }

            // Start Timer
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!isGameOver) {
                    timeLeft--;
                    updateUI();
                    if (timeLeft <= 0) {
                        endGame();
                    }
                }
            }, 1000);
        }

        function spawnAppleAt(r, c) {
            // Random value 1-9
            const val = Math.floor(Math.random() * 9) + 1;
            
            // If updating an existing apple, find it, otherwise push new
            const existingIndex = apples.findIndex(a => a.r === r && a.c === c);
            
            const apple = {
                r: r,
                c: c,
                val: val,
                scale: 0, // For pop-in animation (0 to 1)
                removed: false
            };

            if (existingIndex !== -1) {
                apples[existingIndex] = apple;
            } else {
                apples.push(apple);
            }
        }

        function endGame() {
            isGameOver = true;
            clearInterval(timerInterval);
        }

        function updateUI() {
            uiScore.textContent = score;
            const percent = (timeLeft / GAME_DURATION) * 100;
            timerBar.style.height = `${percent}%`;
            const timeEl = document.getElementById('time-display');
            if (timeEl) timeEl.textContent = timeLeft;
        }

        // --- Core Game Loop ---

        function gameLoop(timestamp) {
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(timestamp) {
            const dt = timestamp - lastFrameTime;
            lastFrameTime = timestamp;

            // Animate apples appearing (pop-in effect)
            apples.forEach(a => {
                if (a.scale < 1) {
                    a.scale += 0.1; // Animation speed
                    if (a.scale > 1) a.scale = 1;
                }
            });

            // Clear feedback box after 300ms
            if (feedbackBox && timestamp - feedbackBox.timestamp > 300) {
                feedbackBox = null;
            }
        }

        // --- Rendering ---

        function draw() {
            // Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Draw Apples (Red Apple Icon)
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `bold ${cellSize * 0.6}px Arial`;

            apples.forEach(a => {
                if (a.removed) return; // skip removed cells, leave empty
                const centerX = (a.c * cellSize) + (cellSize / 2);
                const centerY = (a.r * cellSize) + (cellSize / 2);
                const radius = (cellSize * 0.4) * a.scale;

                // Apple Body
                ctx.fillStyle = isLightMode ? '#ffadad' : '#e74c3c';
                ctx.beginPath();
                ctx.arc(centerX, centerY + radius*0.1, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Apple Stem (simple arc)
                ctx.strokeStyle = '#8d6e63';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY - radius, radius * 0.3, Math.PI*0.7, Math.PI*1.3);
                ctx.stroke();

                // Number
                ctx.fillStyle = '#fff'; // White text
                ctx.fillText(a.val, centerX, centerY + radius*0.1);
            });

            // 2. Draw Active Selection Box (sum hint removed)
            if (input.isDragging && !isGameOver) {
                const rect = getNormalizedRect(input.startX, input.startY, input.currX, input.currY);

                ctx.fillStyle = 'rgba(0, 200, 83, 0.3)'; // Green tint
                ctx.fillRect(rect.x, rect.y, rect.w, rect.h);

                ctx.strokeStyle = '#00c853';
                ctx.lineWidth = 2;
                ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
            }

            // 3. Draw Feedback Flash (Green/Red border)
            if (feedbackBox) {
                ctx.strokeStyle = feedbackBox.color;
                ctx.lineWidth = 5;
                ctx.strokeRect(feedbackBox.x, feedbackBox.y, feedbackBox.w, feedbackBox.h);
            }

            // 4a. Draw Start Overlay (before game begins)
                        if (!isGameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                            // Centered overlay content
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 40px Arial';
                            const centerX = canvas.width / 2;
                            const centerY = canvas.height / 2;
                            ctx.fillText('Sum Fruit', centerX, centerY - 110);

                                // Guide text
                                ctx.font = '16px Arial';
                                const guideLines = [
                                    'How to Play:',
                                    '- Drag to select apples. If their sum equals 10,',
                                    '  the selected apples disappear and leave empty spaces.',
                                    '- Use thin selections to pick precise rows/columns.',
                                    '- Score increases by the number of apples removed.',
                                    '- Grid stays empty until you finish or reset.',
                                ];
                                const lineGap = 22;
                                const blockHeight = guideLines.length * lineGap;
                                let gy = centerY - blockHeight / 2;
                                guideLines.forEach((line, i) => {
                                    ctx.fillText(line, centerX, gy + i * lineGap);
                                });

                // Draw Start Button
                const btnW = 200;
                const btnH = 60;
                const btnX = centerX - btnW / 2;
                const btnY = centerY + 130;

                ctx.fillStyle = '#27ae60';
                ctx.fillRect(btnX, btnY, btnW, btnH);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('Start', canvas.width / 2, btnY + btnH / 2);

                // Store button bounds for click detection
                window.startBtn = { x: btnX, y: btnY, w: btnW, h: btnH };
                return; // avoid drawing rest
            }

            // 4b. Draw Game Over Overlay
            if (isGameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 40px Arial';
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                ctx.fillText("Time's Up!", cx, cy - 40);
                ctx.font = '30px Arial';
                ctx.fillText(`Final Score: ${score}`, cx, cy + 5);

                // Play Again text button
                const label = 'Play Again';
                ctx.font = 'bold 24px Arial';
                const textMetrics = ctx.measureText(label);
                const textW = Math.ceil(textMetrics.width);
                const paddingX = 18;
                const paddingY = 10;
                const btnW = textW + paddingX * 2;
                const btnH = 40;
                const btnX = cx - btnW / 2;
                const btnY = cy + 60;

                // Button background
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(btnX, btnY, btnW, btnH);
                ctx.strokeStyle = '#1b8f4d';
                ctx.lineWidth = 2;
                ctx.strokeRect(btnX, btnY, btnW, btnH);

                // Button label
                ctx.fillStyle = '#fff';
                ctx.fillText(label, cx, btnY + btnH / 2);

                // Store button bounds for click detection
                window.playAgainBtn = { x: btnX, y: btnY, w: btnW, h: btnH };
            }
        }

        // --- Logic & Helper Functions ---

        // Converts screen selection to rectangle {x, y, w, h}
        function getNormalizedRect(x1, y1, x2, y2) {
            return {
                x: Math.min(x1, x2),
                y: Math.min(y1, y2),
                w: Math.abs(x2 - x1),
                h: Math.abs(y2 - y1)
            };
        }

        function getSelectedApples(rect) {
            // Consider a cell selected if the selection rectangle intersects any portion of the cell box.
            return apples.filter(a => {
                if (a.removed) return false;
                const cellX = a.c * cellSize;
                const cellY = a.r * cellSize;
                const intersects = (
                    rect.x < cellX + cellSize &&
                    rect.x + rect.w > cellX &&
                    rect.y < cellY + cellSize &&
                    rect.y + rect.h > cellY
                );
                return intersects;
            });
        }

        // --- Input Handling ---

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleInputStart(e) {
            // Handle Start UI click
            if (!isGameStarted) {
                const pos = getPointerPos(e);
                if (window.startBtn && 
                    pos.x >= window.startBtn.x && pos.x <= window.startBtn.x + window.startBtn.w &&
                    pos.y >= window.startBtn.y && pos.y <= window.startBtn.y + window.startBtn.h) {
                    startGame();
                }
                return;
            }
            // Handle Play Again button in game over UI
            if (isGameOver) {
                const pos = getPointerPos(e);
                if (window.playAgainBtn &&
                    pos.x >= window.playAgainBtn.x && pos.x <= window.playAgainBtn.x + window.playAgainBtn.w &&
                    pos.y >= window.playAgainBtn.y && pos.y <= window.playAgainBtn.y + window.playAgainBtn.h) {
                    startGame();
                }
                return;
            }
            e.preventDefault(); // Stop text selection
            const pos = getPointerPos(e);
            input.isDragging = true;
            input.startX = pos.x;
            input.startY = pos.y;
            input.currX = pos.x;
            input.currY = pos.y;
        }

        function handleInputMove(e) {
            if (!input.isDragging) return;
            if (e.touches) e.preventDefault(); // Prevent scrolling on mobile
            
            const pos = getPointerPos(e);
            input.currX = pos.x;
            input.currY = pos.y;
        }

        function handleInputEnd(e) {
            if (!input.isDragging) return;
            input.isDragging = false;

            // Logic check
            const selectionRect = getNormalizedRect(input.startX, input.startY, input.currX, input.currY);
            
            // Allow very thin selections; only ignore true clicks (<2px both ways)
            if (selectionRect.w < 2 && selectionRect.h < 2) return;

            const selectedApples = getSelectedApples(selectionRect);
            const sum = selectedApples.reduce((s, a) => s + a.val, 0);

            if (sum === 10) {
                // Success
                score += selectedApples.length;
                updateUI();
                
                // Visual Flash Green
                feedbackBox = { ...selectionRect, color: '#00e676', timestamp: performance.now() };

                // Remove but DO NOT respawn; leave grid empty
                selectedApples.forEach(a => {
                    const idx = apples.findIndex(x => x.r === a.r && x.c === a.c);
                    if (idx !== -1) {
                        apples[idx].removed = true;
                    }
                });
            } else {
                // Failure Flash Red
                feedbackBox = { ...selectionRect, color: '#ff3d00', timestamp: performance.now() };
            }
        }

        // --- Resizing ---

        function resizeCanvas() {
            // Get available space in main frame
            const frame = document.getElementById('main-frame');
            // Calculate max available width/height for the canvas container
            // Considering padding and other UI elements
            const maxW = window.innerWidth * 0.9; // 90% of screen width
            const maxH = window.innerHeight * 0.75; // 75% of screen height

            // Calculate cell size to fit grid entirely within limits
            const maxCellWidth = maxW / GRID_COLS;
            const maxCellHeight = maxH / GRID_ROWS;
            
            cellSize = Math.floor(Math.min(maxCellWidth, maxCellHeight));

            // Set canvas and container size
            const finalW = cellSize * GRID_COLS;
            const finalH = cellSize * GRID_ROWS;
            
            canvas.width = finalW;
            canvas.height = finalH;
            container.style.width = `${finalW}px`;
            container.style.height = `${finalH}px`;
            container.style.backgroundSize = `${cellSize}px ${cellSize}px`;

            // Adjust timer height to match canvas
            timerContainer.style.height = `${finalH}px`;

            draw();
        }

        // Boot
        initGame();

    </script>
</body>
</html>